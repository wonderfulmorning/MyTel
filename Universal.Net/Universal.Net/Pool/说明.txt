Universal.Net.Pool 主要提供一些池对象
最基础的池对象提供的功能包括：存储对象，获取和归还对象
最丰富的的池对象提供的功能包括：存储对象，获取和归还对象，对象重置，限制同一对象被多次出池和还池，线程安全，资源的释放，信息监视。

池对象的基本功能：http://www.cnblogs.com/mezero/p/3955130.html
如果你搜索下用C#实现的对象池类库，你会发现其中很多是相当复杂的。我们先暂停一下，仔细想想在一个通用的对象池中到底哪些是我们需要的，哪些是不需要的：

    很多类型的对象被重新使用前，在某些情况下，需要被reset。至少，所有的成员变量都要设置成初始值。这可以在池中实现而不需要用户处理。何时和如何重置需要考虑以下两个方面：
        重置是立即的（例如，在存储对象时即重置）还是延迟的（例如，在对象被重新使用后重置）。
        重置是被池管理（例如，对于被放入池中的对象来说是透明的）还是声明池对象的类。
    在上面的例子中，poolofMyClass池对象需要显示申明在类级别作用域。显然，当我们需要一个其它类型的对象池时就需要重新申明一个。或许我们可以实现一个对用户透明。
    创建管理所有类型池的ObjectPool。
    一些对象池类库管理了太多种类的可怕的资源（如内存，数据库连接，游戏对象，外部资产等）。这无疑增加了对象池的代码复杂度。
    某些类型的资源是很珍贵的（如数据库连接），池需要显示上限并提供一个针对分配对象失败的安全措施；
    当池中对象很多却很少使用时，或许需要收缩的功能（不管是自动的还是强制的）。
    最后，池可以被多个线程共享，因此需要实现为线程安全的。

 那么其中那些是必需的呢？你的答案或许和我的不一样，但请允许我阐述我的观点：

    重置是必需的。但是正如你将在下面看的那样，我并没有强制到底是在池中还是被管理类中处理重置逻辑。你可能两种都需要，之后的代码中我将向你展示各自两个版本。
    Unity强制限制多线程。你可以在主线程中定义工作者线程，但只有主线程可以调用Unity API。以我的经验看来，我们并不需要将池实现为支持多线程。
    仅个人而言，我并不介意每次为一个类型申明一个新的池。可选的方案是采用单例模式：创建一个新的对象池并放置于存储池的字典中，该字典放置在一个静态变量中。为了安全使用，你需要将将你的对象池实现为支持多线程。但就我看到的对象池而言没有一个是100%安全的。
    在本篇文章中我重点处理内存。其它类型资源池也是很重要的，但超出本篇文章的范围。这很大程度上减少了以下的需求：
        不需要一个作限制用的最大值。如果你的游戏使用太多的资源，你已经陷入麻烦了，对象池也救不了你。
         我们也可以假设没有其它进程等待你尽快释放内存。这就意味着重置可以是延迟的，也不需要提供收缩功能。

参考：http://www.cnblogs.com/hsapphire/archive/2010/12/09/1901237.html

